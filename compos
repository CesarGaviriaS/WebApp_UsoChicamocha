import { writable } from 'svelte/store';
import { get } from 'svelte/store';
import { EventSourcePolyfill } from 'event-source-polyfill';
import { auth } from '../stores/auth.js';
import { data } from '../stores/data.js';
import { ui, addNotification, notificationMessages, notificationCount } from '../stores/ui.js';

// Notification types
export const NOTIFICATION_TYPES = {
  INSPECTION: 'inspection',
  DATA_UPDATE: 'data-update',
  SOAT_RUNT: 'soat-runt',
  OIL_CHANGE: 'oil-change'
};

// Notification service store
export const notificationService = writable({
  isConnected: false,
  connection: null,
  type: null,
  isReconnecting: false
});

// Active notification streams - PERSISTENT (never close)
let inspectionStream = null;
let dataUpdateStream = null;
let soatRuntStream = null;
let oilChangeStream = null;

// Base URL from environment
const BASE_URL = import.meta.env.VITE_API_BASE_URL;

// Audio context for notification sounds
let audioCtx = null;
let soundNeedsActivation = true;

export function initializeNotifications() {
  const token = localStorage.getItem('accessToken');
  
  console.log("ğŸ”” [NOTIFICATIONS] === INICIO DE INICIALIZACIÃ“N (PERSISTENTE) ===", new Date().toLocaleTimeString());
  console.log("ğŸ”” [NOTIFICATIONS] Token disponible:", token ? "SÃ" : "NO");
  console.log("ğŸ”” [NOTIFICATIONS] Base URL disponible:", BASE_URL ? "SÃ" : "NO");
  console.log("ğŸ”” [NOTIFICATIONS] Auth state:", get(auth).isAuthenticated);
  console.log("ğŸ”” [NOTIFICATIONS] IMPORTANTE: STREAMS NUNCA SE CIERRAN");
  
  if (!BASE_URL || !token) {
    console.warn("âŒ [NOTIFICATIONS] No se puede inicializar notificaciones: falta la URL base o el token.");
    console.log("ğŸ”” [NOTIFICATIONS] BASE_URL:", BASE_URL);
    console.log("ğŸ”” [NOTIFICATIONS] token:", token ? "presente" : "ausente");
    return;
  }

  console.log("ğŸ”” [NOTIFICATIONS] Conectando a todos los streams (PERSISTENTES)...");
  connectToAllStreams(token);
  console.log("ğŸ”” [NOTIFICATIONS] Activando sonido...");
  activateSound();
  console.log("ğŸ”” [NOTIFICATIONS] === INICIALIZACIÃ“N COMPLETA - STREAMS ACTIVOS ===");
}

function connectToAllStreams(token) {
  console.log("ğŸ”” [NOTIFICATIONS] Iniciando conexiones de streams PERSISTENTES...");
  
  // Connect to inspection notifications
  console.log("ğŸ”” [NOTIFICATIONS] â†’ Conectando stream de INSPECCIONES (PERSISTENTE)...");
  connectInspectionStream(token);
  
  // Connect to data updates  
  console.log("ğŸ”” [NOTIFICATIONS] â†’ Conectando stream de ACTUALIZACIÃ“N DE DATOS (PERSISTENTE)...");
  connectDataUpdateStream(token);
  
  // Connect to SOAT/RUNT notifications
  console.log("ğŸ”” [NOTIFICATIONS] â†’ Conectando stream SOAT/RUNT (PERSISTENTE)...");
  connectSoatRuntStream(token);
  
  // Connect to oil change notifications
  console.log("ğŸ”” [NOTIFICATIONS] â†’ Conectando stream de CAMBIOS DE ACEITE (PERSISTENTE)...");
  connectOilChangeStream(token);
  
  console.log("ğŸ”” [NOTIFICATIONS] Todas las conexiones de streams PERSISTENTES iniciadas.");
}

function connectInspectionStream(token) {
  const streamUrl = `${BASE_URL}/inspections/stream?token=${encodeURIComponent(token)}`;
  console.log("ğŸ”” [INSPECTION] Creando EventSource PERSISTENTE para:", streamUrl);
  
  inspectionStream = new EventSourcePolyfill(streamUrl);
  
  inspectionStream.onopen = () => {
    console.log("âœ… [INSPECTION] Conectado al stream de inspecciones (PERSISTENTE).", new Date().toLocaleTimeString());
    updateConnectionStatus(NOTIFICATION_TYPES.INSPECTION, true);
  };
  
  inspectionStream.onmessage = (event) => {
    const timestamp = new Date().toLocaleTimeString();
    console.log("ğŸ“¨ [INSPECTION] Mensaje recibido en", timestamp);
    console.log("ğŸ“¨ [INSPECTION] Raw data:", event.data);
    
    const message = event.data;
    if (message === 'stream_open') {
      console.log('âœ… [INSPECTION] Notificaciones de inspecciones confirmadas.');
      return;
    }
    
    try {
      console.log("ğŸ” [INSPECTION] Procesando mensaje JSON...");
      const newInspection = JSON.parse(event.data);
      console.log("ğŸ” [INSPECTION] Inspection parseada:", newInspection);
      
      const machineInfo = newInspection.machine ? 
        `${newInspection.machine.name} ${newInspection.machine.model}` : 
        'una mÃ¡quina';
      
      console.log("ğŸ”” [INSPECTION] Agregando notificaciÃ³n:", `Â¡IMPREVISTO EN ${machineInfo}!`);

      addNotification({
        id: newInspection.UUID || Date.now(),
        text: `Â¡IMPREVISTO EN ${machineInfo}!`
      });

      console.log("ğŸ”Š [INSPECTION] Reproduciendo sonido...");
      playNotificationSound();

      // Auto-refresh dashboard if on inspection view
      const currentView = get(ui).currentView;
      console.log("ğŸ”„ [INSPECTION] Vista actual:", currentView);
      
      if (currentView === 'dashboard') {
        console.log("ğŸ”„ [INSPECTION] Actualizando dashboard...");
        const dataState = get(data);
        console.log("ğŸ”„ [INSPECTION] Estado de datos:", dataState.dashboard);
        data.fetchDashboardData(dataState.dashboard.currentPage, dataState.dashboard.pageSize);
      }
    } catch (e) {
      console.error("âŒ [INSPECTION] Error procesando mensaje:", e.message);
      console.error("âŒ [INSPECTION] Mensaje que causÃ³ error:", event.data);
    }
  };
  
  inspectionStream.onerror = (err) => {
    const timestamp = new Date().toLocaleTimeString();
    console.warn("âš ï¸ [INSPECTION] Error temporal en stream en", timestamp, err);
    console.log("âš ï¸ [INSPECTION] STREAM MANTIENE CONEXIÃ“N - NO SE CIERRA");
    console.log("âš ï¸ [INSPECTION] El stream continÃºa escuchando...");
    // NO SE CIERRA EL STREAM - SE MANTIENE ACTIVO
  };
}

function connectDataUpdateStream(token) {
  const streamUrl = `${BASE_URL}/new-data/notifications/stream?token=${encodeURIComponent(token)}`;
  console.log("ğŸ”” [DATA_UPDATE] Creando EventSource PERSISTENTE para:", streamUrl);
  
  dataUpdateStream = new EventSourcePolyfill(streamUrl);
  
  dataUpdateStream.onopen = () => {
    console.log("âœ… [DATA_UPDATE] Conectado al stream de actualizaciÃ³n de datos (PERSISTENTE).", new Date().toLocaleTimeString());
    updateConnectionStatus(NOTIFICATION_TYPES.DATA_UPDATE, true);
  };
  
  dataUpdateStream.onmessage = (event) => {
    const timestamp = new Date().toLocaleTimeString();
    console.log("ğŸ“¨ [DATA_UPDATE] Mensaje recibido en", timestamp);
    console.log("ğŸ“¨ [DATA_UPDATE] Raw data:", event.data);
    
    const message = event.data;
    if (message === 'stream_open') {
      console.log('âœ… [DATA_UPDATE] Notificaciones de actualizaciÃ³n confirmadas.');
      return;
    }
    
    const currentView = get(ui).currentView;
    console.log(`ğŸ”„ [DATA_UPDATE] Mensaje: "${message}", Vista actual: "${currentView}"`);

    // Route data updates to appropriate refresh functions
    handleDataUpdate(currentView, message);
  };
  
  dataUpdateStream.onerror = (err) => {
    const timestamp = new Date().toLocaleTimeString();
    console.warn("âš ï¸ [DATA_UPDATE] Error temporal en stream en", timestamp, err);
    console.log("âš ï¸ [DATA_UPDATE] STREAM MANTIENE CONEXIÃ“N - NO SE CIERRA");
    console.log("âš ï¸ [DATA_UPDATE] El stream continÃºa escuchando...");
    // NO SE CIERRA EL STREAM - SE MANTIENE ACTIVO
  };
}

function connectSoatRuntStream(token) {
  const streamUrl = `${BASE_URL}/soat/runt/notifications/stream?token=${encodeURIComponent(token)}`;
  console.log("ğŸ”” [SOAT_RUNT] Creando EventSource PERSISTENTE para:", streamUrl);
  
  soatRuntStream = new EventSourcePolyfill(streamUrl);
  
  soatRuntStream.onopen = () => {
    console.log("âœ… [SOAT_RUNT] Conectado al stream SOAT/RUNT (PERSISTENTE).", new Date().toLocaleTimeString());
    updateConnectionStatus(NOTIFICATION_TYPES.SOAT_RUNT, true);
  };
  
  soatRuntStream.onmessage = (event) => {
    const timestamp = new Date().toLocaleTimeString();
    console.log("ğŸ“¨ [SOAT_RUNT] Mensaje recibido en", timestamp);
    console.log("ğŸ“¨ [SOAT_RUNT] Raw data:", event.data);
    
    const message = event.data;
    if (message === 'stream_open') {
      console.log('âœ… [SOAT_RUNT] Notificaciones SOAT/RUNT confirmadas.');
      return;
    }
    
    try {
      console.log("ğŸ” [SOAT_RUNT] Procesando mensaje JSON...");
      const notificationData = JSON.parse(event.data);
      console.log("ğŸ” [SOAT_RUNT] Notification parseada:", notificationData);

      console.log("ğŸ”” [SOAT_RUNT] Agregando notificaciÃ³n:", notificationData.message || 'NotificaciÃ³n SOAT/RUNT');
      
      addNotification({
        id: notificationData.id || Date.now(),
        text: notificationData.message || 'NotificaciÃ³n SOAT/RUNT'
      });
      // No sound for this stream
    } catch (e) {
      console.error("âŒ [SOAT_RUNT] Error procesando mensaje:", e.message);
      console.error("âŒ [SOAT_RUNT] Mensaje que causÃ³ error:", event.data);
    }
  };
  
  soatRuntStream.onerror = (err) => {
    const timestamp = new Date().toLocaleTimeString();
    console.warn("âš ï¸ [SOAT_RUNT] Error temporal en stream en", timestamp, err);
    console.log("âš ï¸ [SOAT_RUNT] STREAM MANTIENE CONEXIÃ“N - NO SE CIERRA");
    console.log("âš ï¸ [SOAT_RUNT] El stream continÃºa escuchando...");
    // NO SE CIERRA EL STREAM - SE MANTIENE ACTIVO
  };
}

function connectOilChangeStream(token) {
  const streamUrl = `${BASE_URL}/oil_change/notifications/stream?token=${encodeURIComponent(token)}`;
  console.log("ğŸ”” [OIL_CHANGE] Creando EventSource PERSISTENTE para:", streamUrl);
  
  oilChangeStream = new EventSourcePolyfill(streamUrl);
  
  oilChangeStream.onopen = () => {
    console.log("âœ… [OIL_CHANGE] Conectado al stream de cambios de aceite (PERSISTENTE).", new Date().toLocaleTimeString());
    updateConnectionStatus(NOTIFICATION_TYPES.OIL_CHANGE, true);
  };
  
  oilChangeStream.onmessage = (event) => {
    const timestamp = new Date().toLocaleTimeString();
    console.log("ğŸ“¨ [OIL_CHANGE] Mensaje recibido en", timestamp);
    console.log("ğŸ“¨ [OIL_CHANGE] Raw data:", event.data);
    
    const message = event.data;
    if (message === 'stream_open') {
      console.log('âœ… [OIL_CHANGE] Notificaciones de cambios de aceite confirmadas.');
      return;
    }
    
    try {
      console.log("ğŸ” [OIL_CHANGE] Procesando mensaje JSON...");
      const notificationData = JSON.parse(event.data);
      console.log("ğŸ” [OIL_CHANGE] Notification parseada:", notificationData);

      console.log("ğŸ”” [OIL_CHANGE] Agregando notificaciÃ³n:", notificationData.message || 'NotificaciÃ³n de cambio de aceite');
      
      addNotification({
        id: notificationData.id || Date.now(),
        text: notificationData.message || 'NotificaciÃ³n de cambio de aceite'
      });
      // No sound for this stream
    } catch (e) {
      console.error("âŒ [OIL_CHANGE] Error procesando mensaje:", e.message);
      console.error("âŒ [OIL_CHANGE] Mensaje que causÃ³ error:", event.data);
    }
  };
  
  oilChangeStream.onerror = (err) => {
    const timestamp = new Date().toLocaleTimeString();
    console.warn("âš ï¸ [OIL_CHANGE] Error temporal en stream en", timestamp, err);
    console.log("âš ï¸ [OIL_CHANGE] STREAM MANTIENE CONEXIÃ“N - NO SE CIERRA");
    console.log("âš ï¸ [OIL_CHANGE] El stream continÃºa escuchando...");
    // NO SE CIERRA EL STREAM - SE MANTIENE ACTIVO
  };
}

function handleDataUpdate(currentView, message) {
  console.log("ğŸ”„ [DATA_UPDATE] Manejando actualizaciÃ³n para vista:", currentView, "mensaje:", message);
  
  const dataState = get(data);
  console.log("ğŸ”„ [DATA_UPDATE] Estado actual de datos:", {
    dashboard: dataState.dashboard?.currentPage,
    workOrders: dataState.workOrders?.currentPage
  });
  
  switch (message) {
    case 'inspections-updated':
      if (currentView === 'dashboard') {
        console.log('ğŸ”„ [DATA_UPDATE] Recargando tabla de inspecciones...');
        data.fetchDashboardData(dataState.dashboard.currentPage, dataState.dashboard.pageSize);
      }
      break;
    case 'machines-updated':
      if (currentView === 'machines') {
        console.log('ğŸ”„ [DATA_UPDATE] Recargando tabla de mÃ¡quinas...');
        data.fetchMachines();
      }
      break;
    case 'users-updated':
      if (currentView === 'users') {
        console.log('ğŸ”„ [DATA_UPDATE] Recargando tabla de usuarios...');
        data.fetchUsers();
      }
      break;
    case 'orders-updated':
      if (currentView === 'work-orders') {
        console.log('ğŸ”„ [DATA_UPDATE] Recargando tabla de Ã³rdenes de trabajo...');
        data.fetchWorkOrders(dataState.workOrders.currentPage, dataState.workOrders.pageSize);
      }
      break;
    case 'oil-changes-updated':
      if (currentView === 'consolidado') {
        console.log('ğŸ”„ [DATA_UPDATE] Recargando tabla de consolidado...');
        data.fetchConsolidadoData();
      }
      break;
    default:
      console.log("âš ï¸ [DATA_UPDATE] Mensaje no reconocido:", message);
  }
}

// ELIMINADO: handleStreamError - los streams NUNCA se cierran
// ELIMINADO: reconnectStream - los streams NUNCA se reconectan

function updateConnectionStatus(type, isConnected, isReconnecting = false) {
  console.log(`ğŸ“Š [CONNECTION] Estado actualizado - Tipo: ${type}, Conectado: ${isConnected}, Reconectando: ${isReconnecting}`);
  
  notificationService.update(state => ({
    ...state,
    isConnected: isConnected || state.isConnected,
    type: isConnected ? type : state.type,
    isReconnecting: false // SIEMPRE false - no hay reconexiÃ³n
  }));
}

// MODIFICADO: disconnectFromAllStreams - SOLO cuando el usuario hace logout explÃ­citamente
export function disconnectFromAllStreams() {
  console.log("ğŸ”Œ [DISCONNECT] LOGOUT - Cerrando todos los streams (solo en logout)...");
  
  [inspectionStream, dataUpdateStream, soatRuntStream, oilChangeStream].forEach((stream, index) => {
    if (stream) {
      console.log("ğŸ”Œ [DISCONNECT] Cerrando stream:", index, "por logout");
      stream.close();
      stream = null;
    }
  });
  
  notificationService.set({
    isConnected: false,
    connection: null,
    type: null,
    isReconnecting: false
  });
  
  console.log("ğŸ”Œ [DISCONNECT] Todos los streams cerrados por logout.");
}

// Audio functions
export function activateSound() {
  console.log("ğŸ”Š [AUDIO] Activando contexto de audio...");
  
  if (!audioCtx) {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      soundNeedsActivation = false;
      console.log("ğŸ”Š [AUDIO] Contexto de audio activado exitosamente.");
    } catch(e) {
      console.error("âŒ [AUDIO] Web Audio API no es soportada:", e.message);
      soundNeedsActivation = false;
    }
  } else {
    console.log("ğŸ”Š [AUDIO] Contexto de audio ya existÃ­a, activÃ¡ndolo...");
    soundNeedsActivation = false;
  }
}

export function playNotificationSound() {
  console.log("ğŸ”Š [AUDIO] Intentando reproducir sonido...");
  
  if (!audioCtx) {
    console.warn("âš ï¸ [AUDIO] El audio debe ser activado por un gesto del usuario.");
    return;
  }
  if (audioCtx.state === "suspended") {
    console.log("ğŸ”Š [AUDIO] Reanudando contexto de audio...");
    audioCtx.resume();
  }

  const now = audioCtx.currentTime;
  const oscillator = audioCtx.createOscillator();
  const gainNode = audioCtx.createGain();

  oscillator.connect(gainNode);
  gainNode.connect(audioCtx.destination);

  oscillator.type = "sine";
  oscillator.frequency.setValueAtTime(800, now);
  oscillator.frequency.linearRampToValueAtTime(600, now + 0.15);

  gainNode.gain.setValueAtTime(0, now);
  gainNode.gain.linearRampToValueAtTime(0.4, now + 0.02);
  gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.25);
  
  console.log("ğŸ”Š [AUDIO] Sonido iniciado.");
  
  oscillator.start(now);
  oscillator.stop(now + 0.25);
  
  console.log("ğŸ”Š [AUDIO] Sonido programado para terminar en 0.25s.");
}

export function getSoundNeedsActivation() {
  console.log("ğŸ”Š [AUDIO] Estado de activaciÃ³n:", soundNeedsActivation);
  return soundNeedsActivation;
}

export function getConnectionStatus() {
  const status = notificationService;
  console.log("ğŸ“Š [STATUS] Obteniendo estado de conexiÃ³n...");
  return status;
}